; ex 1
(defun power-of-two (val)
    (do
        ((cur val (1- cur)) (res 2 (* 2 res)))
        ((= cur 1) res)
    )
)
(print (power-of-two 1))
(print (power-of-two 2))
(print (power-of-two 3))
(print (power-of-two 5))
(print (power-of-two 10))
(print (power-of-two 20))
(print "------------")
;ex 2
(defun it-remove (el val)
    (reverse (do
        ((cur val (cdr cur)) (res nil (cond ((not (equal el (car cur))) (cons (car cur) res)))))
        ((null cur) res)
    ))
)
(print (it-remove 'a '()))
(print (it-remove 'a '(a)))
(print (it-remove 'a '(b c)))
(print (it-remove 'a '(a b c)))
(print "------------")
(defun it-remove1 (el val)
    (do
        ((cur val (cdr cur)) (res nil (cond ((not (equal el (car cur))) (append res (list (car cur)))))))
        ((null cur) res)
    )
)
(print (it-remove1 'a '()))
(print (it-remove1 'a '(a)))
(print (it-remove1 'a '(b c)))
(print (it-remove1 'a '(a b c)))
(print "------------")
;ex 3
(defun it-assoc (el val)
    (do
        ((cur val (cdr cur)) (res nil (cond ((equal el (caar cur)) (append (car cur) res)))))
        ( (or (not ( null res)) (null cur)) res)
    )
)
(print (it-assoc 'y '((y a))))
(print (it-assoc 'y '(())))
(print (it-assoc 'y '((a b) (b c) (c d))))
(print (it-assoc 'y '((a b) (b c) (c d)(y f))))
(print "------------")
;ex 4
(defun it-fact (num)
    (do
        ((cur num (1- cur)) (res 1 (* res cur)))
        ((= cur 1) res)
    )
)
(print (it-fact 1))
(print (it-fact 2))
(print (it-fact 3))
(print (it-fact 4))
(print (it-fact 10))
(print (it-fact 100))
(print "------------")
;ex 5
(defun it-pairlis (l1 l2)
    (do
        ((cur (list l1 l2) (list (cdar cur) (cdadr cur))) (res nil (append res (list (list (caar cur)(caadr cur))) ) ))
        ((or (null (car cur)) (null (cadr cur))) res)
    )
)
(print (it-pairlis '() '()))
(print (it-pairlis '(a b) '(1 2) ))
(print (it-pairlis '(a b c) '(1 2) ))
(print (it-pairlis '(a b c) '(1 2 3 4) ))
(print (it-pairlis '(a b c) '() ))